# 全端技術架構文件: PCM (專業營建管理)

## 1. 簡介 (Introduction)

本文件旨在闡述「PCM 專業營建管理」專案的完整全端技術架構，內容涵蓋後端系統、前端實作及其整合方式。它將作為 AI 開發代理與工程師團隊的唯一技術真相來源 (Single Source of Truth)，確保整個技術堆疊的一致性。

### 啟動範本或既有專案 (Starter Template or Existing Project)
根據先前已確認的技術選型（Next.js 與 shadcn/ui），本架構文件將假設專案是透過標準的 `create-next-app` 指令進行初始化，並在此基礎上整合 shadcn/ui。這為我們提供了業界標準的專案結構與開發工具鏈。

### 變更日誌 (Change Log)
| 日期 | 版本 | 描述 | 作者 |
| :--- | :--- | :--- | :--- |
| 2025-09-08 | 1.0 | 初始架構文件建立 | Winston (Architect) |

## 2. 高層次架構 (High-Level Architecture)

### 技術摘要 (Technical Summary)
PCM 系統將被建構成一個全端、無伺服器 (Serverless) 的網頁應用程式，並基於 Next.js 框架開發。前端將採用 React 與 shadcn/ui 元件庫打造，而後端邏輯則透過 Next.js API Routes 實現。整個應用程式將會被容器化為一個 Docker 映像檔，部署於客戶的地端虛擬化環境中，並使用 Oracle 資料庫作為其主要的數據儲存層。此架構採用 Monorepo 模式進行程式碼管理，以利於前後端之間的型別共享與協同開發。

### 平台與基礎設施 (Platform and Infrastructure)
* **部署平台**: 地端虛擬化主機 (On-Premise Virtualization)
* **容器化技術**: Docker
* **資料庫**: Oracle

### 程式碼庫結構 (Repository Structure)
* **結構**: Monorepo
* **管理工具**: 採用 `npm workspaces` 或類似工具來管理單一儲存庫中的多個套件。

### 高層次架構圖 (High-Level Architecture Diagram)
使用者透過瀏覽器與部署在 Docker 中的 PCM 應用程式互動。此應用程式包含前端與後端，並會連接至 Oracle 資料庫、檔案儲存體，以及外部的刷卡機 API。

### 架構模式 (Architectural and Design Patterns)
* **無伺服器架構 (Serverless Architecture)**: 利用 Next.js API Routes 作為後端。
* **元件化 UI (Component-Based UI)**: 透過可重複使用的 React 元件來建構介面。
* **倉儲模式 (Repository Pattern)**: 在後端，分離業務邏輯與資料存取邏輯。

## 3. 技術堆疊 (Tech Stack)
| 類別 | 技術 | 版本 | 用途與理由 |
| :--- | :--- | :--- | :--- |
| **前端框架** | Next.js | `14.x` | 核心的全端應用程式框架。 |
| **UI 元件庫** | shadcn/ui | `Latest` | 提供高品質、可客製化的 UI 元件基礎。 |
| **前後端語言** | TypeScript | `5.x` | 提供靜態型別檢查，提升程式碼的健壯性。 |
| **狀態管理** | React Context / Zustand | `18.x` / `4.x` | 分別處理簡單與複雜的客戶端狀態。 |
| **資料庫** | Oracle | `待確認版本` | 核心資料儲存。 |
| **認證與授權** | NextAuth.js (Auth.js) | `5.x` | Next.js 生態系中最主流的認證函式庫。 |
| **測試** | Jest / React Testing Library / Playwright | `Latest` | 分別用於單元、元件與端對端測試。 |
| **部署** | Docker / Docker Compose | `Latest` | 用於建立容器化的開發與生產環境。 |
| **CI/CD** | Jenkins | `Latest LTS` | 業界最通用的開源 CI/CD 工具。 |
| **日誌與監控**| Netdata | `Latest` | 輕量、簡單的 All-in-One 監控方案。 |

## 4. 資料模型 (Data Models)
此處定義了第一階段所需的13個核心資料模型及其 TypeScript 介面，包括：
* **使用者 (User)**: 儲存使用者基本資訊與登入憑證。
* **專案 (Project)**: 儲存營建專案的核心資訊。
* **角色 (Role)**: 定義系統中的使用者角色。
* **使用者角色關聯 (UserRole)**: 將使用者與角色進行多對多關聯。
* **協力廠商 (Subcontractor)**: 儲存協力廠商公司的基本資訊。
* **廠商人員 (Personnel)**: 儲存屬於協力廠商的個人員工資訊。
* **工作分解結構項目 (WBS_Item)**: 儲存專案的階層式 WBS。
* **WBS 變更紀錄 (WBS_Change_Log)**: 記錄對 WBS 項目的修改歷史。
* **每日報告 (Daily_Report)**: 儲存進度報告。
* **報告附件 (Report_Attachment)**: 儲存報告的附件檔案資訊。
* **公告 (Announcement)**: 儲存最新消息。
* **值班表 (Duty_Roster)**: 記錄人員值班日期。
* **出勤紀錄 (Attendance)**: 儲存刷卡機的出勤紀錄。

## 5. API 規格 (API Specification)
採用 OpenAPI 3.0 標準定義了第一階段所需的 REST API 端點。
* **認證**: `POST /api/auth/login`, `POST /api/auth/logout`, `GET /api/auth/session`
* **專案**: `GET /api/projects`
* **協力廠商與人員**: `GET, POST, PUT, DELETE /api/subcontractors/{id}`, `GET, POST, PUT, DELETE /api/personnel/{id}`
* **其他**: 包含角色、值班表、出勤、WBS、報告、公告等資源的增刪改查端點。

## 6. 元件 (Components)
將系統劃分為五大邏輯元件：
* **前端應用程式**: 處理所有使用者介面的渲染與互動。
* **後端服務 (API)**: 處理所有業務邏輯、資料庫互動與外部系統整合。
* **認證服務**: 專責處理使用者登入、登出、會話管理。
* **資料庫**: 持久化儲存所有應用程式資料。
* **檔案儲存體**: 儲存使用者上傳的檔案。

## 7. 外部 API (External APIs)
* **刷卡機系統 API**: 用於接收每日人員出勤打卡紀錄，細節待確認。
* **PowerBI 整合**: 規劃透過資料庫直接連線或定時匯出資料的方式進行整合。

## 8. 核心工作流程 (Core Workflows)
使用者登入時，前端會將帳號密碼發送至後端服務。後端服務會查詢 Oracle 資料庫來驗證憑證，驗證成功後會建立一個安全的 Session 並回傳給前端，前端接著將使用者導向至專案選擇頁面。

## 9. 資料庫結構 (Database Schema)
```sql
-- 使用者表
CREATE TABLE USERS (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR2(255) NOT NULL UNIQUE,
    hashed_password VARCHAR2(255) NOT NULL,
    full_name NVARCHAR2(255),
    email VARCHAR2(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- 專案表
CREATE TABLE PROJECTS (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name NVARCHAR2(255) NOT NULL,
    code VARCHAR2(50) UNIQUE,
    status NVARCHAR2(50),
    start_date DATE,
    planned_submission_date DATE,
    total_duration_days NUMBER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- ... 以及其他如 ROLES, USER_ROLES, SUBCONTRACTORS, PERSONNEL 等資料表的 CREATE 語句。
```

### 10. 前端架構 (Frontend Architecture)

#### 元件架構 (Component Architecture)

##### 1. 元件組織結構 (Component Organization)
為了保持程式碼的整潔與可維護性，我們採用以下的分層目錄結構來組織我們的 React 元件：
```plaintext
apps/web/src/
├── app/                  # Next.js App Router: 放置所有頁面與路由。
├── components/
│   ├── ui/               # 放置由 shadcn/ui 產生的基礎 UI 元件 (如 Button, Card)。
│   ├── common/           # 放置由基礎元件組合而成、可在全站共用的通用元件 (例如頁首 PageHeader)。
│   └── features/         # 放置與特定功能相關的複雜元件 (例如專案列表 ProjectList, WBS 樹狀圖 WBS-Tree)。
├── lib/                  # 放置共用的工具函式 (utils)。
└── services/             # 放置所有與後端 API 溝通的程式碼。
```

##### 2. 元件範本 (Component Template)
所有新的 React 元件都應遵循以下使用 TypeScript 的標準範本。這是一個 ProjectCard 元件範例：
```
// 檔案路徑: apps/web/src/components/features/ProjectCard.tsx
import React from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';
import { Project } from '@/lib/types'; // 假設我們將共用型別放在 lib/types.ts

interface ProjectCardProps {
  project: Project;
}

const ProjectCard: React.FC<ProjectCardProps> = ({ project }) => {
  return (
    <Card className="cursor-pointer hover:shadow-lg transition-shadow">
      <CardHeader>
        <CardTitle>{project.name}</CardTitle>
      </CardHeader>
      <CardContent>
        <p>狀態：{project.status}</p>
        <Progress value={/* 計算進度 */} className="w-full" />
      </CardContent>
    </Card>
  );
};

export default ProjectCard;
```
#### 狀態管理架構 (State Management Architecture)
我們將「伺服器狀態」與「客戶端狀態」分開管理：

伺服器狀態 (Server State): 從後端 API 取得的資料，使用 TanStack Query (React Query) 來管理，它能自動處理快取、背景更新與資料同步。

客戶端狀態 (Client State): 存活於 UI 中的狀態（如表單內容），使用 Zustand 來進行管理。

#### 狀態儲存結構 (Store Structure)
```
apps/web/src/
├── stores/
│   ├── userStore.ts       # 管理使用者登入狀態、個人資料。
│   ├── projectStore.ts    # 管理專案列表、當前選擇的專案等。
│   └── uiStore.ts         # 管理全域 UI 狀態 (例如：載入中、通知訊息)。
```

#### 路由架構 (Routing Architecture)
1. 路由組織結構 (Route Organization)
採用 Next.js App Router 以目錄為基礎的路由系統，並使用「路由群組 (Route Groups)」來組織：
```
apps/web/src/app/
├── (auth)/             # 放置「不需」登入即可存取的頁面
│   └── login/
│       └── page.tsx
├── (main)/             # 放置「需要」登入才能存取的主應用程式頁面
│   ├── layout.tsx
│   ├── projects/
│   │   └── page.tsx
│   └── (project)/
│       └── [projectId]/
│           ├── dashboard/page.tsx
│           └── ...
└── page.tsx
```

2. 受保護路由模式 (Protected Route Pattern)
使用 middleware.ts 檔案來保護在 (main) 群組下的所有路由。此 middleware 會檢查使用者的 Session，若未登入，則自動重新導向至 /login 頁面。

#### 前端服務層 (Frontend Services Layer)
1. API 客戶端設定 (API Client Setup)
建立一個中央化的 API 客戶端實例 (axios)，並設定「攔截器 (Interceptors)」來統一處理認證與錯誤。
```
// 檔案路徑: apps/web/src/lib/api.ts
import axios from 'axios';

const apiClient = axios.create({
  baseURL: '/api',
  headers: { 'Content-Type': 'application/json' },
});

apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default apiClient;
```

2. 服務層範例 (Service Example)
將所有與特定資料相關的 API 請求，封裝在對應的 "service" 檔案中。
```
// 檔案路徑: apps/web/src/services/projectService.ts
import apiClient from '@/lib/api';
import { Project } from '@/lib/types';

export const getProjects = async (): Promise<Project[]> => {
  try {
    const response = await apiClient.get('/projects');
    return response.data;
  } catch (error) {
    console.error("Failed to fetch projects:", error);
    return [];
  }
};
```

### 11. 後端架構 (Backend Architecture)
#### 服務架構 (Service Architecture)
1. 函式組織結構 (Function Organization)
所有後端 API 邏輯存放在 app/api/ 目錄下，並根據資源分子目錄：
```
apps/web/src/app/api/
├── auth/
│   └── [...nextauth]/route.ts
├── projects/
│   └── route.ts
├── subcontractors/
│   ├── route.ts
│   └── [id]/route.ts
└── ...
```
2. 函式範本 (Function Template)
每個 API 路由都遵循標準範本，包含身份驗證、業務邏輯分離、統一錯誤處理。
```
// 檔案路徑: apps/web/src/app/api/projects/route.ts
import { NextResponse } from 'next/server';
import { getProjectsForUser } from '@/services/projectService';
import { auth } from '@/lib/auth';

export async function GET(request: Request) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return new NextResponse('Unauthorized', { status: 401 });
    }
    const projects = await getProjectsForUser(session.user.id);
    return NextResponse.json(projects);
  } catch (error) {
    console.error('[PROJECTS_GET] Error:', error);
    return new NextResponse('Internal Server Error', { status: 500 });
  }
}
```

#### 資料庫架構 (Database Architecture)
1. 資料庫結構設計 (Schema Design)
遵循先前在「資料庫結構 (Database Schema)」章節中定義的 CREATE TABLE SQL 語句。

2. 資料存取層 (Data Access Layer)
採用倉儲模式 (Repository Pattern)，將所有 SQL 查詢封裝在 Repository 檔案中，業務邏輯層 (Service) 只呼叫 Repository。
```
// 檔案路徑: apps/web/src/repositories/projectRepository.ts
import { db } from '@/lib/db';
import { Project } from '@/lib/types';

export const projectRepository = {
  async findByUserId(userId: number): Promise<Project[]> {
    const result = await db.query(
      'SELECT * FROM PROJECTS p JOIN USER_PROJECTS up ON p.id = up.project_id WHERE up.user_id = :userId',
      { userId }
    );
    return result.rows as Project[];
  }
};
```
認證與授權架構 (Authentication & Authorization Architecture)
使用 NextAuth.js 處理認證，並透過 Callbacks 將使用者角色資訊注入 Session Token，以供後端進行授權判斷。

### 12. 統一專案結構 (Unified Project Structure)
```
/pcm-project/
├── apps/
│   └── web/                    # 核心 Next.js 應用程式 (含前後端)
│       ├── src/
│       │   ├── app/              # 頁面與 API 路由
│       │   ├── components/       # 前端 React 元件
│       │   ├── lib/              # 共用函式庫
│       │   ├── repositories/   # 後端倉儲層
│       │   └── services/         # 業務邏輯服務層
├── packages/                   # 共享套件
│   └── shared/                 # 共享的 TypeScript 型別
├── infrastructure/             # 基礎設施設定
│   └── docker-compose.yml
└── ...
```

### 13. 開發流程 (Development Workflow)
環境前置需求: Node.js, Docker, Git。

初次設定步驟: git clone, npm install, cp .env.example .env, docker-compose up -d, npm run db:seed。

開發常用指令: npm run dev, npm run test, npm run lint。

環境變數: 定義了 DATABASE_URL, NEXTAUTH_URL, NEXTAUTH_SECRET 等。

### 14. 部署架構 (Deployment Architecture)
部署策略: 採用「藍綠部署 (Blue-Green Deployment)」以實現零停機時間的回滾。

CI/CD 管線: 使用 Jenkins，包含 build, deploy_to_staging, deploy_to_production 等階段。

環境: 定義了 Development, Staging, Production 三種環境。

### 15. 安全性與效能 (Security and Performance)
安全性需求: 包含前後端的輸入驗證、XSS 防範、SQL 注入防範、API 速率限制、安全的密碼儲存與 Session 管理。

效能優化: 包含前端的程式碼分割與圖片優化，以及後端的資料庫索引、分頁查詢與快取策略。

### 16. 測試策略 (Testing Strategy)
測試金字塔: 採用單元測試、整合測試、端對端測試結合的策略。

測試組織: 定義了前端、後端與 E2E 測試檔案的存放位置。

測試範例:
```
// E2E 測試範例 (使用 Playwright)
test('使用者應能成功登入並看到專案選擇頁', async ({ page }) => {
  await page.goto('/login');
  await page.fill('input[name="username"]', 'testuser');
  await page.fill('input[name="password"]', 'password123');
  await page.click('button[type="submit"]');
  await expect(page).toHaveURL('/projects');
  await expect(page.getByText('選擇專案')).toBeVisible();
});
```

### 17. 編碼標準 (Coding Standards)
#### 核心編碼規則:

服務層與倉儲層分離: 業務邏輯與資料庫操作分離。

#### 型別共享: 共用型別需定義在 packages/shared/ 中。

#### 環境變數存取: 需透過集中的設定檔讀取。

#### API 錯誤處理: 需使用統一的錯誤處理機制。

#### 元件狀態管理: 需區分伺服器狀態與客戶端狀態。

命名慣例:
| 元素 | 慣例 | 範例 |
| :--- | :--- | :--- |
| React 元件檔 | 大駝峰 (PascalCase) | ProjectCard.tsx |
| API 路由檔 | route.ts | app/api/projects/route.ts |
| Oracle 資料表 | 全大寫蛇形 (UPPER_SNAKE_CASE) | PROJECTS, USER_ROLES |